# Main file for location of notation.
Amatrix:
  args: 0
  latex: \mathbf{A}
KL:
  args: 2
  latex: '\text{KL}\left( #1\,\|\,#2 \right)'
  description: Kullback Leibler divergence
Kaast:
  latex: \kernelMatrix_{\mathbf{ \ast}\mathbf{ \ast}}
Kastu:
  latex: \kernelMatrix_{\mathbf{\ast} \inducingVector}
Kff:
  latex: \kernelMatrix_{\mappingFunctionVector \mappingFunctionVector}
Kfu:
  latex: \kernelMatrix_{\mappingFunctionVector \inducingVector}
Kuast:
  latex: \kernelMatrix_{\inducingVector \bf\ast}
Kuf:
  latex: \kernelMatrix_{\inducingVector \mappingFunctionVector}
Kuu:
  latex: \kernelMatrix_{\inducingVector \inducingVector}
Kuui:
  latex: \Kuu^{-1}
Qaast:
  latex: '{\bf Q}_{\bf \ast \ast}'
Qastf:
  latex: '{\bf Q}_{\ast \mappingFunction}'
Qfast:
  latex: '{\bf Q}_{\mappingFunctionVector \bf \ast}'
Qff:
  latex: '{\bf Q}_{\mappingFunctionVector \mappingFunctionVector}'
aMatrix:
  latex: \mathbf{A}
aScalar:
  latex: a
aVector:
  latex: \mathbf{a}
acceleration:
  latex: a
bMatrix:
  latex: \mathbf{B}
bScalar:
  latex: b
bVector:
  latex: \mathbf{b}
basisFunc:
  latex: \phi
basisFuncVector:
  latex: \boldsymbol{\basisFunc}
basisFunction:
  latex: \phi
basisLocation:
  latex: \mu
basisMatrix:
  latex: \boldsymbol{\Phi}
basisScalar:
  latex: \basisFunction
basisVector:
  latex: \boldsymbol{\basisFunction}
bigO:
  latex: \mathcal{O}
binomProb:
  latex: \pi
cMatrix:
  latex: \mathbf{C}
cbasisMatrix:
  latex: \hat{\boldsymbol{\Phi}}
cdataMatrix:
  latex: \hat{\dataMatrix}
cdataScalar:
  latex: \hat{\dataScalar}
cdataVector:
  latex: \hat{\dataVector}
centeredKernelMatrix:
  latex: \mathbf{\MakeUppercase{\centeredKernelScalar}}
centeredKernelScalar:
  latex: b
centeredKernelVector:
  latex: \centeredKernelScalar
centeringMatrix:
  latex: \mathbf{H}
chiSquaredDist:
  args: 2
  latex: \chi_{#1}^{2}\left(#2\right)
chiSquaredSamp:
  args: 1
  latex: \chi_{#1}^{2}
conditionalCovariance:
  latex: \boldsymbol{\Sigma}
coregionalizationMatrix:
  latex: \mathbf{\MakeUppercase{\coregionalizationScalar}}
coregionalizationScalar:
  latex: b
coregionalizationVector:
  latex: \mathbf{\coregionalizationScalar}
covDist:
  args: 2
  latex: \text{cov}_{#2}\left(#1\right)
covSamp:
  args: 1
  latex: \text{cov}\left(#1\right)
covarianceScalar:
  latex: c
covarianceVector:
  latex: \mathbf{\covarianceScalar}
covarianceMatrix:
  latex: \mathbf{\MakeUppercase{\covarianceScalar}}
croupierScalar:
  latex: s
croupierVector:
  latex: \mathbf{\croupierScalar}
croupierMatrix:
  latex: \mathbf{\MakeUppercase{\croupierScalar}}
dataDim:
  latex: p
dataIndex:
  latex: i
dataIndexTwo:
  latex: j
dataMatrix:
  latex: \mathbf{\MakeUppercase{\dataScalar}}
dataScalar:
  latex: y
dataSet:
  latex: \mathcal{D}
dataStd:
  latex: \sigma
dataVector:
  latex: \mathbf{\dataScalar}
decayRate:
  latex: d
degreeMatrix:
  latex: \mathbf{\MakeUppercase{\degreeScalar}}
degreeScalar:
  latex: d
degreeVector:
  latex: \mathbf{\degreeScalar}
det:
  args: 1
  latex: \left|#1\right|
diag:
  args: 1
  latex: \text{diag}\left(#1\right)
diagonalMatrix:
  latex: \mathbf{D}
diff:
  args: 2
  latex: \frac{\text{d}#1}{\text{d}#2}
diffTwo:
  args: 2
  latex: \frac{\text{d}^2#1}{\text{d}#2^2}
displacement:
  latex: x
displacementVector:
  latex: \textbf{\displacement}
distanceMatrix:
  latex: \mathbf{\MakeUppercase{\distanceScalar}}
distanceScalar:
  latex: d
distanceVector:
  latex: \mathbf{\distanceScalar}
eigenvaltwo:
  latex: \ell
eigenvaltwoMatrix:
  latex: \mathbf{L}
eigenvaltwoVector:
  latex: \mathbf{l}
eigenvalue:
  latex: \lambda
eigenvalueMatrix:
  latex: \boldsymbol{\Lambda}
eigenvalueVector:
  latex: \boldsymbol{\lambda}
eigenvector:
  latex: \mathbf{\eigenvectorScalar}
eigenvectorMatrix:
  latex: \mathbf{\MakeUppercase{\eigenvectorScalar}}
eigenvectorScalar:
  latex: u
eigenvectwo:
  latex: \mathbf{v}
eigenvectwoMatrix:
  latex: \mathbf{V}
eigenvectwoScalar:
  latex: v
entropy:
  args: 1
  latex: \mathcal{H}\left(#1\right)
errorFunction:
  latex: E
expDist:
  args: 2
  latex: \left<#1\right>_{#2}
expSamp:
  args: 1
  latex: \left<#1\right>
expectation:
  args: 1
  latex: '\left\langle #1 \right\rangle '
expectationDist:
  args: 2
  latex: '\left\langle #1 \right\rangle _{#2}'
expectedDistanceMatrix:
  latex: \mathcal{D}
eye:
  latex: \mathbf{I}
fantasyDim:
  latex: r
fantasyMatrix:
  latex: \mathbf{\MakeUppercase{\fantasyScalar}}
fantasyScalar:
  latex: z
fantasyVector:
  latex: \mathbf{\fantasyScalar}
featureStd:
  latex: \varsigma
gammaCdf:
  args: 3
  latex: \mathcal{GAMMA CDF}\left(#1|#2,#3\right)
gammaDist:
  args: 3
  latex: \mathcal{G}\left(#1|#2,#3\right)
gammaSamp:
  args: 2
  latex: \mathcal{G}\left(#1,#2\right)
gaussianDist:
  args: 3
  latex: \mathcal{N}\left(#1|#2,#3\right)
gaussianSamp:
  args: 2
  latex: \mathcal{N}\left(#1,#2\right)
half:
  latex: \frac{1}{2}
heaviside:
  latex: H
hiddenMatrix:
  latex: \mathbf{\MakeUppercase{\hiddenScalar}}
hiddenScalar:
  latex: h
hiddenVector:
  latex: \mathbf{\hiddenScalar}
identityMatrix:
  latex: \eye
inducingInputScalar:
  latex: z
inducingInputVector:
  latex: \mathbf{\inducingInputScalar}
inducingInputMatrix:
  latex: \mathbf{\MakeUppercase{\inducingInputScalar}}
inducingScalar:
  latex: u
inducingVector:
  latex: \mathbf{\inducingScalar}
inducingMatrix:
  latex: \mathbf{\MakeUppercase{\inducingScalar}}
inlineDiff:
  args: 2
  latex: '\text{d}#1/\text{d}#2'
inputDim:
  latex: q
inputMatrix:
  latex: '{\bf \MakeUppercase{\inputScalar}}'
inputScalar:
  latex: x
inputSpace:
  latex: \mathcal{X}
inputVector:
  latex: '{\bf \inputScalar}'
iterNum:
  latex: k
kernel:
  latex: \kernelScalar
kernelMatrix:
  latex: \mathbf{\MakeUppercase{\kernelScalar}}
  description: Kernel matrix
kernelScalar:
  latex: k
kernelVector:
  latex: \mathbf{\kernelScalar}
kff:
  latex: \kernelScalar_{\mappingFunction \mappingFunction}
kfu:
  latex: \kernelVector_{\mappingFunction \inducingScalar}
kuf:
  latex: \kernelVector_{\inducingScalar \mappingFunction}
kuu:
  latex: \kernelVector_{\inducingScalar \inducingScalar}
lagrangeMultiplier:
  latex: \lambda
lagrangeMultiplierMatrix:
  latex: \boldsymbol{\Lambda}
lagrangian:
  latex: L
laplacianFactor:
  latex: \mathbf{\MakeUppercase{\laplacianFactorScalar}}
laplacianFactorScalar:
  latex: m
laplacianFactorVector:
  latex: \mathbf{\laplacianFactorScalar}
laplacianMatrix:
  latex: \mathbf{L}
laplacianScalar:
  latex: \ell
laplacianVector:
  latex: \mathbf{\ell}
latentDim:
  latex: q
latentDistanceMatrix:
  latex: \boldsymbol{\Delta}
latentDistanceScalar:
  latex: \delta
latentDistanceVector:
  latex: \boldsymbol{\delta}
latentForce:
  latex: f
latentFunction:
  latex: u
latentFunctionVector:
  latex: \mathbf{\latentFunction}
latentFunctionMatrix:
  latex: \mathbf{\MakeUppercase{\latentFunction}}
latentIndex:
  latex: j
latentScalar:
  latex: x
latentVector:
  latex: \mathbf{\latentScalar}
latentMatrix:
  latex: \mathbf{\MakeUppercase{\latentScalar}}
learnRate:
  latex: \eta
lengthScale:
  latex: \ell
rbfWidth:
  latex: \ell
likelihoodBound:
  latex: \mathcal{L}
likelihoodFunction:
  latex: L
locationScalar:
  latex: \mu
locationVector:
  latex: \boldsymbol{\locationScalar}
locationMatrix:
  latex: \mathbf{M}
variance:
  args: 1
  latex: '\text{var}\left( #1 \right)'
mappingFunction:
  latex: f
mappingFunctionMatrix:
  latex: \mathbf{\MakeUppercase{\mappingFunction}}
mappingFunctionTwo:
  latex: g
mappingFunctionTwoMatrix:
  latex: \mathbf{\MakeUppercase{\mappingFunctionTwo}}
mappingFunctionTwoVector:
  latex: \mathbf{\mappingFunctionTwo}
mappingFunctionVector:
  latex: \mathbf{\mappingFunction}
mappingScalar:
  latex: w
mappingVector:
  latex: \mathbf{\mappingScalar}
mappingMatrix:
  latex: \mathbf{W}
mappingScalarTwo:
  latex: v
mappingVectorTwo:
  latex: \mathbf{\mappingScalarTwo}
mappingMatrixTwo:
  latex: \mathbf{\MakeUppercase{\mappingScalarTwo}}
maxIters:
  latex: K
meanMatrix:
  latex: \mathbf{M}
meanScalar:
  latex: \mu
meanTwoMatrix:
  latex: \mathbf{\MakeUppercase{\meanTwoScalar}}
meanTwoScalar:
  latex: m
meanTwoVector:
  latex: \mathbf{\meanTwoScalar}
meanVector:
  latex: \boldsymbol{\meanScalar}
mrnaConcentration:
  latex: m
naturalFrequency:
  latex: \omega
neighborhood:
  args: 1
  latex: '\mathcal{N}\left( #1 \right)'
neilurl:
  latex: http://inverseprobability.com/
noiseMatrix:
  latex: \boldsymbol{E}
noiseScalar:
  latex: \epsilon
noiseVector:
  latex: \boldsymbol{\epsilon}
norm:
  args: 1
  latex: '\left\Vert #1 \right\Vert'
normalizedLaplacianMatrix:
  latex: \hat{\mathbf{L}}
normalizedLaplacianScalar:
  latex: \hat{\ell}
normalizedLaplacianVector:
  latex: \hat{\mathbf{\ell}}
numActive:
  latex: m
numBasisFunc:
  latex: m
numComponents:
  latex: m
numComps:
  latex: K
numData:
  latex: n
  description: number of data points in the data set
numFeatures:
  latex: K
numHidden:
  latex: h
numInducing:
  latex: m
  description: number of inducing variables in a GP model
numLayers:
  latex: \ell
numNeighbors:
  latex: K
numSequences:
  latex: s
numSuccess:
  latex: s
numTasks:
  latex: m
numTime:
  latex: T
numTrials:
  latex: S
outputIndex:
  latex: j
paramVector:
  latex: \boldsymbol{\theta}
parameterMatrix:
  latex: \boldsymbol{\Theta}
parameterScalar:
  latex: \theta
parameterVector:
  latex: \boldsymbol{\parameterScalar}
partDiff:
  args: 2
  latex: '\frac{\partial#1}{\partial#2}'
precisionScalar:
  latex: j
precisionVector:
  latex: \mathbf{\precisionScalar}
precisionMatrix:
  latex: \mathbf{\MakeUppercase{\precisionScalar}}
pseudotargetScalar:
  latex: \widetilde{y}
pseudotargetVector:
  latex: \mathbf{\pseudotargetScalar}
pseudotargetMatrix:
  latex: \mathbf{\MakeUppercase{\pseudotargetScalar}}
rank:
  args: 1
  latex: '\text{rank}\left(#1\right)'
rayleighDist:
  args: 2
  latex: '\mathcal{R}\left(#1|#2\right)'
rayleighSamp:
  args: 1
  latex: '\mathcal{R}\left(#1\right)'
responsibility:
  latex: r
rotationScalar:
  latex: r
rotationVector:
  latex: \mathbf{\rotationScalar}
rotationMatrix:
  latex: \mathbf{\MakeUppercase{\rotationScalar}}
sampleCovScalar:
  latex: s
sampleCovVector:
  latex: \mathbf{\sampleCovScalar}
sampleCovMatrix:
  latex: \mathbf{\MakeUppercase{\sampleCovScalar}}
scalarProduct:
  args: 2
  latex: '\left\langle{#1},{#2}\right\rangle'
sign:
  args: 1
  latex: '\text{sign}\left(#1\right)'
singularvalue:
  latex: \ell
singularvalueMatrix:
  latex: \mathbf{L}
singularvalueVector:
  latex: \mathbf{l}
sorth:
  latex: \mathbf{u}
spar:
  latex: \lambda
BasalRate:
  latex: B
DampingCoefficient:
  latex: C
DecayRate:
  latex: D
Displacement:
  latex: X
LatentForce:
  latex: F
Mass:
  latex: M
Sensitivity:
  latex: S
basalRate:
  latex: b
dampingCoefficient:
  latex: c
mass:
  latex: m
sensitivity:
  latex: s
springScalar:
  latex: \kappa
springVector:
  latex: \boldsymbol{\kappa}
springMatrix:
  latex: \boldsymbol{\mathcal{K}}
tfConcentration:
  latex: p
tfDecayRate:
  latex: \delta
tfMrnaConcentration:
  latex: f
tfVector:
  latex: '{\bf \tfConcentration}'
velocity:
  latex: v
sufficientStatsScalar:
  latex: g
sufficientStatsVector:
  latex: \mathbf{\sufficientStatsScalar}
sufficientStatsMatrix:
  latex: \mathbf{\MakeUppercase{\sufficientStatsScalar}}
switchScalar:
  latex: s
switchVector:
  latex: \mathbf{\switchScalar}
switchMatrix:
  latex: \mathbf{\MakeUppercase{\switchScalar}}
tr:
  args: 1
  latex: '\text{tr}\left(#1\right)'
  description: matrix trace
loneNorm:
  args: 1
  latex: '\left\Vert #1 \right\Vert_1'
ltwoNorm:
  args: 1
  latex: '\left\Vert #1 \right\Vert_2'
onenorm:
  args: 1
  latex: '\left\vert#1\right\vert_1'
twonorm:
  args: 1
  latex: '\left\Vert #1 \right\Vert'
vScalar:
  latex: v
vVector:
  latex: \mathbf{v}
vMatrix:
  latex: \mathbf{V}
varianceDist:
  args: 2
  latex: '\text{var}_{#2}\left( #1 \right)'
vec:
  args: 1
  latex: '#1:'
vecb:
  args: 1
  latex: '\left(#1\right):'
weightScalar:
  latex: w
weightVector:
  latex: \mathbf{\weightScalar}
weightMatrix:
  latex: \mathbf{\MakeUppercase{\weightScalar}}
weightedAdjacencyMatrix:
  latex: \mathbf{\MakeUppercase{\weightedAdjacencyScalar}}
weightedAdjacencyScalar:
  latex: a
weightedAdjacencyVector:
  latex: \mathbf{\weightedAdjacencyScalar}
onesVector:
  latex: \mathbf{1}
  description: vector of ones
zerosVector:
  latex: \mathbf{0}
  description: vector of zeros
